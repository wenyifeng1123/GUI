# -*- coding: utf-8 -*-
import os
import numpy as np
import matplotlib.pyplot as plt
import matplotlib
matplotlib.use("Qt5Agg")
from PyQt5 import QtCore
from PyQt5.QtCore import pyqtSlot,QStringListModel,pyqtSignal
#from PyQt5.QtWidgets import QApplication, QMainWindow, QVBoxLayout, QSizePolicy, QWidget, QListView,QMessageBox,QFileDialog,QDialog,QPushButton
from PyQt5.QtCore import *
from PyQt5.QtGui import *
from PyQt5.QtWidgets import *
from numpy import arange, sin, pi
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from Ui_matplotlib_pyqt_2ListView import Ui_MainWindow
import h5py
#from network_visualization import plot_mosaic,on_click


class MainWindow(QMainWindow, Ui_MainWindow):
    """
    Class documentation goes here.
    """

    def __init__(self, parent=None):
        """
        Constructor
        @param parent reference to the parent widget
        @type QWidget
        """
        super(MainWindow, self).__init__(parent)
        self.setupUi(self)

        self.matplotlibwidget_static.hide()
        self.matplotlibwidget_static_2.hide()

        #in the listView the select name will save in chosenActivationName
        self.chosenActivationName = []
        # the slider's value is the chosen patch's number
        self.chosenPatchNumber = 0
        self.openfile_name=''
        self.qList=[]
        self.totalPatches=0

        # from the .h5 file extract the name of each layer and the total number of patches
        self.pushButton_4.clicked.connect(self.openfile)
        self.listView.clicked.connect(self.clickList_1)

        #self.horizontalSlider.valueChanged.connect(self.sliderValue)
        self.horizontalSlider.sliderReleased.connect(self.sliderValue)

    def openfile(self):
        self.openfile_name = QFileDialog.getOpenFileName(self,'Choose the file','.','H5 files(*.h5)')[0]
        self.qList, self.totalPatches = self.show_activation_names()
        self.horizontalSlider.setMinimum(0)
        self.horizontalSlider.setMaximum(self.totalPatches - 1)

    def sliderValue(self):
        self.chosenPatchNumber=self.horizontalSlider.value()
        self.matplotlibwidget_static_2.mpl.feature_plot(self.chosenActivationName, self.chosenPatchNumber,self.openfile_name)

    @pyqtSlot()
    def on_pushButton_clicked(self):
        if len(self.openfile_name) != 0:
            # show the weights
            self.matplotlibwidget_static_2.hide()
            self.matplotlibwidget_static.show()
            self.matplotlibwidget_static.mpl.weights_plot(self.openfile_name)
        else:
            self.showChooseFileDialog()

    @pyqtSlot()
    def on_pushButton_2_clicked(self):

        if len(self.openfile_name)!=0:
            self.matplotlibwidget_static.hide()
            # show the activations' name in the List
            slm = QStringListModel();
            slm.setStringList(self.qList)
            self.listView.setModel(slm)
        else:
            self.showChooseFileDialog()


    @pyqtSlot()
    def on_pushButton_3_clicked(self):
        if len(self.openfile_name) != 0 :
            if len(self.chosenActivationName)!=0:
                # choose which layer's feature maps to be plotted
                self.matplotlibwidget_static.hide()
                self.matplotlibwidget_static_2.show()
                self.matplotlibwidget_static_2.mpl.feature_plot(self.chosenActivationName, self.chosenPatchNumber,self.openfile_name)
            else:
                self.showChooseLayerDialog()
        else:
            self.showChooseFileDialog()



    def clickList_1(self, qModelIndex):
        self.chosenActivationName = self.qList[qModelIndex.row()]

    def show_activation_names(self):
        qList = []
        model = h5py.File(self.openfile_name, 'r')
        layersName = []
        layersFeatures = {}
        totalPatches = 0

        for i in model['layers']:
            layerIndex = 'layers' + '/' + i

            for n in model[layerIndex]:
                qList.append(n)

                if int(i) == 0:
                    layerName = layerIndex + '/' + n
                    layersName.append(n)
                    featurePath = layerName + '/' + 'activation'
                    layersFeatures[n] = model[featurePath]
                    totalPatches = layersFeatures[n].shape[0]

        return qList, totalPatches

    def showChooseFileDialog(self):
        reply = QMessageBox.information(self,
                                        "Warning",
                                        "Please select one H5 File at first",
                                        QMessageBox.Ok )

    def showChooseLayerDialog(self):
        reply = QMessageBox.information(self,
                                        "Warning",
                                        "Please select one Layer at first",
                                        QMessageBox.Ok)

class MyMplCanvas(FigureCanvas):

    def __init__(self, parent=None, width=15, height=15):

        plt.rcParams['font.family'] = ['SimHei']
        plt.rcParams['axes.unicode_minus'] = False

        self.fig = plt.figure(figsize=(width, height))
        self.openfile_name=''

        FigureCanvas.__init__(self, self.fig)
        self.setParent(parent)

        FigureCanvas.setSizePolicy(self,QSizePolicy.Expanding,QSizePolicy.Expanding)
        FigureCanvas.updateGeometry(self)




    def weights_plot(self,openfile_name):

        self.openfile_name=openfile_name
        layersName, layersWeights = self.getLayersWeights()
        layerLength = len(layersName)
        axNumber = layerLength * 2 - 1

        for i in range(axNumber):

            self.axes = self.fig.add_subplot(axNumber, 1, i + 1)
            if i % 2 == 0:
                bbox_props = dict(boxstyle="round", fc="w", ec="0.5", alpha=0.9)
                self.axes.text(0.5, 0.5, layersName[int(i / 2)], ha="center", va="center", size=20,
                               bbox=bbox_props)
                self.axes.name = layersName[int(i / 2)]
            elif i != axNumber - 1:
                self.axes.annotate('', xy=(0.5, 0), xytext=(0.5, 1),
                                   arrowprops=dict(facecolor='black', shrink=0.05))
                self.axes.name = 'arrow'
            else:
                pass

            self.axes.set_axis_off()

        self.fig.canvas.mpl_connect('button_press_event', self.on_click_axes)

    def feature_plot(self,feature_map,ind,openfile_name):

        self.openfile_name=openfile_name
        layersName, activations = self.getLayersFeatures()


        if activations[feature_map].ndim == 4:
            featMap=activations[feature_map][ind]

            # Compute nrows and ncols for images
            n_mosaic = len(featMap)
            nrows = int(np.round(np.sqrt(n_mosaic)))
            ncols = int(nrows)
            if (nrows ** 2) < n_mosaic:
                ncols += 1

            self.fig.clear()
            # self.draw()
            # self.show()
            self.plot_feature_mosaic(featMap, nrows, ncols)
            self.fig.suptitle("Feature Maps of Patch #{} in Layer '{}'".format(ind, feature_map))
            self.draw()
        else:
            pass

    def on_click_axes(self,event):
        """Enlarge or restore the selected axis."""

        ax = event.inaxes
        layersName, layersWeights = self.getLayersWeights()
        if ax is None:

            return
        if event.button is 1:

            f = plt.figure()
            if ax.name == 'arrow':
                return

            w = layersWeights[ax.name].value
            if w.ndim == 4:
                w = np.transpose(w, (3, 2, 0, 1))
                mosaic_number = w.shape[0]
                nrows = int(np.round(np.sqrt(mosaic_number)))
                ncols = int(nrows)

                if nrows ** 2 < mosaic_number:
                    ncols += 1

                f = self.plot_weight_mosaic(w[:mosaic_number, 0], nrows, ncols, f)
                plt.suptitle("Weights of Layer '{}'".format(ax.name))
                f.show()
            else:
                pass
        else:
            # No need to re-draw the canvas if it's not a left or right click
            return
        event.canvas.draw()

    def getLayersWeights(self):
        model = h5py.File(self.openfile_name, 'r')
        layersName = []
        layersWeights = {}

        for i in model['layers']:
            layerIndex = 'layers' + '/' + i

            for n in model[layerIndex]:
                layerName = layerIndex + '/' + n
                layersName.append(n)

                weightsPath = layerName + '/' + 'weights'
                layersWeights[n] = model[weightsPath]
        # model.close()
        return layersName, layersWeights

    def getLayersFeatures(self):
        model = h5py.File(self.openfile_name, 'r')
        layersName = []
        layersFeatures = {}

        for i in model['layers']:
            layerIndex = 'layers' + '/' + i

            for n in model[layerIndex]:
                layerName = layerIndex + '/' + n
                layersName.append(n)

                featurePath = layerName + '/' + 'activation'
                layersFeatures[n] = model[featurePath]
        # model.close()
        return layersName, layersFeatures

    def plot_weight_mosaic(self,im, nrows, ncols, fig,**kwargs):

        # Set default matplotlib parameters
        if not 'interpolation' in kwargs.keys():
            kwargs['interpolation'] = "none"

        if not 'cmap' in kwargs.keys():
            kwargs['cmap'] = "gray"

        nimgs = len(im)
        imshape = im[0].shape

        mosaic = np.zeros(imshape)


        for i in range(nimgs):
            row = int(np.floor(i / ncols))
            col = i % ncols

            ax = fig.add_subplot(nrows, ncols,i+1)
            ax.set_xlim(0,imshape[0]-1)
            ax.set_ylim(0,imshape[1]-1)

            mosaic = im[i]

            ax.imshow(mosaic, **kwargs)
            ax.set_axis_off()

        fig.canvas.mpl_connect('button_press_event', self.on_click)
        return fig


    def plot_feature_mosaic(self,im, nrows, ncols, **kwargs):

        # Set default matplotlib parameters
        if not 'interpolation' in kwargs.keys():
            kwargs['interpolation'] = "none"

        if not 'cmap' in kwargs.keys():
            kwargs['cmap'] = "gray"

        nimgs = len(im)
        imshape = im[0].shape

        mosaic = np.zeros(imshape)
        #fig.clear()

        for i in range(nimgs):
            row = int(np.floor(i / ncols))
            col = i % ncols

            ax = self.fig.add_subplot(nrows, ncols,i+1)
            ax.set_xlim(0,imshape[0]-1)
            ax.set_ylim(0,imshape[1]-1)

            mosaic = im[i]

            ax.imshow(mosaic, **kwargs)
            ax.set_axis_off()
        self.draw()
        self.fig.canvas.mpl_connect('button_press_event', self.on_click)


    def on_click(self,event):
        """Enlarge or restore the selected axis."""
        ax = event.inaxes
        if ax is None:
            # Occurs when a region not in an axis is clicked...
            return
        if event.button is 1:
            # On left click, zoom the selected axes
            ax._orig_position = ax.get_position()
            ax.set_position([0.1, 0.1, 0.85, 0.85])
            for axis in event.canvas.figure.axes:
                # Hide all the other axes...
                if axis is not ax:
                    axis.set_visible(False)
        elif event.button is 3:
            # On right click, restore the axes
            try:
                ax.set_position(ax._orig_position)
                for axis in event.canvas.figure.axes:
                    axis.set_visible(True)
            except AttributeError:
                # If we haven't zoomed, ignore...
                pass
        else:
            # No need to re-draw the canvas if it's not a left or right click
            return
        event.canvas.draw()



class MatplotlibWidget(QWidget):
    def __init__(self, parent=None):
        super(MatplotlibWidget, self).__init__(parent)
        self.initUi()

    def initUi(self):
        self.layout = QVBoxLayout(self)
        self.mpl = MyMplCanvas(self, width=15, height=15)
        self.layout.addWidget(self.mpl)


if __name__ == '__main__':
    import sys
    app = QApplication(sys.argv)
    ui = MainWindow()
    ui.show()
    sys.exit(app.exec_())
