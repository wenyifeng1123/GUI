import os
import theano
import theano.tensor as T
from theano import function

import matplotlib.pyplot as plt
import numpy as np

import keras.backend as K
from keras.datasets import mnist
from keras.models import Sequential
from keras.layers.core import Dense, Dropout, Activation
from keras.optimizers import SGD, Adam, RMSprop
from keras.utils import np_utils
from keras.layers import Dense, Dropout, Activation, Flatten
from keras.layers import Convolution2D, MaxPooling2D
from keras.models import load_model
from keras.utils.vis_utils import plot_model, model_to_dot
import network_visualization
from network_visualization import *
import h5py

# Load dataset


def plot_subset_mosaic( im, nrows, ncols, fig, **kwargs):
    # Set default matplotlib parameters
    if not 'interpolation' in kwargs.keys():
        kwargs['interpolation'] = "none"

    if not 'cmap' in kwargs.keys():
        kwargs['cmap'] = "gray"

    im = np.squeeze(im, axis=1)
    nimgs = len(im)
    imshape = im[0].shape

    mosaic = np.zeros(imshape)

    for i in range(nimgs):
        row = int(np.floor(i / ncols))
        col = i % ncols

        ax = fig.add_subplot(nrows, ncols, i + 1)
        ax.set_xlim(0, imshape[0] - 1)
        ax.set_ylim(0, imshape[1] - 1)

        mosaic = im[i]

        ax.imshow(mosaic, **kwargs)
        ax.set_axis_off()
    #fig.suptitle("Subset Selection of Patch #{} in Layer '{}'".format(ind, feature_map))
    fig.canvas.mpl_connect('button_press_event', on_click)
    return fig

def on_click(event):
    """Enlarge or restore the selected axis."""
    ax = event.inaxes
    if ax is None:
        # Occurs when a region not in an axis is clicked...
        return
    if event.button is 1:
        # On left click, zoom the selected axes
        ax._orig_position = ax.get_position()
        ax.set_position([0.1, 0.1, 0.85, 0.85])
        for axis in event.canvas.figure.axes:
            # Hide all the other axes...
            if axis is not ax:
                axis.set_visible(False)
    elif event.button is 3:
        # On right click, restore the axes
        try:
            ax.set_position(ax._orig_position)
            for axis in event.canvas.figure.axes:
                axis.set_visible(True)
        except AttributeError:
            # If we haven't zoomed, ignore...
            pass
    else:
        # No need to re-draw the canvas if it's not a left or right click
        return
    event.canvas.draw()

(X_train, y_train), (X_test, y_test) = mnist.load_data()

# Only take a small part of the data to reduce computation time

X_train = X_train[:100]
y_train = y_train[:100]
X_test = X_test[:100]
y_test = y_test[:100]

# Define some variables from the dataset

nb_classes = np.unique(y_train).shape[0]
img_rows, img_cols = X_train.shape[-2:]

X_train = X_train.reshape(X_train.shape[0], 1, img_rows, img_cols).astype('float32')
X_test = X_test.reshape(X_test.shape[0], 1, img_rows, img_cols).astype('float32')

X_train /= 255
X_test /= 255

print('X_train shape:', X_train.shape)
print('y_train shape:', y_train.shape)

# Convert class vectors to binary class matrices

Y_train = np_utils.to_categorical(y_train, nb_classes)
Y_test = np_utils.to_categorical(y_test, nb_classes)

# Model parameters

nb_filters = 32
nb_pool = 2
kernel_size = (3, 3)

# Create the model

model = Sequential()

model.add(Convolution2D(nb_filters, (kernel_size[0], kernel_size[1]),
                        border_mode='valid', activation="relu",
                        input_shape=(1, img_rows, img_cols)))

model.add(Convolution2D(nb_filters, kernel_size[0], kernel_size[1],
                        border_mode='valid',activation="relu"))

model.add(MaxPooling2D(pool_size=(nb_pool, nb_pool)))
model.add(Dropout(0.25))

model.add(Flatten())

# model.add(Dense(128))
# model.add(Activation('relu'))
# model.add(Dropout(0.5))

model.add(Dense(nb_classes))
model.add(Activation('softmax'))

model.summary()

model.compile(loss='categorical_crossentropy',
              optimizer=RMSprop(),
              metrics=['accuracy'])

batch_size = 128
nb_epoch = 5

history = model.fit(X_train, Y_train,
                    batch_size=batch_size, nb_epoch=nb_epoch,
                    verbose=1, validation_data=(X_test, Y_test))

activations=[]
for i,layer in enumerate(model.layers):
    get_activations = K.function([model.layers[0].input, K.learning_phase()], [layer.output, ])
    activations.append(get_activations([X_test[:11], 0])[0])


dot = model_to_dot(model, show_shapes=False, show_layer_names=True, rankdir='TB')
layers_by_depth = model.model.layers_by_depth

h=h5py.File('mergeAll.h5','w')
layer_by_depth=h.create_group('layer_by_depth')

## Save the structure, the layers' names in .h5 file
for i in range(len(layers_by_depth)):
    i_layer = layer_by_depth.create_group(str(i)) #the No i layer  in the model
    for ind,layer in enumerate(layers_by_depth[i]): # the layers in No i layer in the model
        i_ind=i_layer.create_group(str(ind))
        layer_name=i_ind.create_dataset('layer_name', data=layer.name)
h.close()


h=h5py.File('mergeAll.h5','r')
i=h['layer_by_depth/0/0/layer_name']
print(i.value)
